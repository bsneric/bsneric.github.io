<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="聚焦 IT 售前解决方案。​在这里，你能学到售前必备的方案撰写技巧，掌握需求分析、竞品应对的实用方法；也能快速理清前沿技术与业务的结合点，让方案更有说服力。"><title>系统分析师必看！OOD 六大设计原则拆解，附 Java 代码示例（从概念到落地一次搞懂） | 解.方.程</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">系统分析师必看！OOD 六大设计原则拆解，附 Java 代码示例（从概念到落地一次搞懂）</h1><a id="logo" href="/.">解.方.程</a><p class="description">解方程：解决方案、方法论、编程技术</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">系统分析师必看！OOD 六大设计原则拆解，附 Java 代码示例（从概念到落地一次搞懂）</h1><div class="post-meta">2025-09-02<span> | </span><span class="category"><a href="/categories/%E8%AE%BE%E8%AE%A1/">设计</a></span></div><div class="post-content"><p>作为一名常年和系统设计打交道的开发者，每次都会被 OOD（面向对象设计）的六大原则戳中 —— 这六条看似抽象的规则，其实是避开 “代码越写越烂” 陷阱的核心心法。</p>
<p>很多人刚接触时会觉得 “这些原则太理论，实际开发用不上”，但只要真正理解并落地，你会发现代码的扩展性、可维护性会发生质的变化。今天就用大白话拆解这六大原则，每个原则都配了 Java 代码示例，从概念到实践一步到位，新手也能看懂。</p>
<h2 id="一、开闭原则：对扩展开放，对修改关闭"><a href="#一、开闭原则：对扩展开放，对修改关闭" class="headerlink" title="一、开闭原则：对扩展开放，对修改关闭"></a>一、开闭原则：对扩展开放，对修改关闭</h2><p><strong>核心概念</strong>：这是 OOD 原则的 “老大”，核心思想是 —— 当需要给系统新增功能时，尽量通过 “扩展已有代码” 实现，而不是 “修改已有代码”。这样能避免改动旧代码时，不小心引入新 Bug，也能让系统更稳定。</p>
<p>举个例子：比如你开发了一个电商系统的 “订单折扣” 功能，初期只有 “会员折扣”，后来要加 “节日折扣”，如果一开始就遵循开闭原则，就不用改原来的会员折扣代码，直接加个新的折扣类就行。</p>
<p>下面给出一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 先定义一个抽象的折扣接口（稳定的抽象层）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Discount</span> &#123;</span><br><span class="line">    <span class="comment">// 计算折扣后的价格</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> originalPrice)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 会员折扣实现类（已有的功能，无需修改）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberDiscount</span> <span class="keyword">implements</span> <span class="title class_">Discount</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> originalPrice)</span> &#123;</span><br><span class="line">        <span class="comment">// 会员打9折</span></span><br><span class="line">        <span class="keyword">return</span> originalPrice * <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 新增节日折扣（扩展新类，不修改旧代码）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HolidayDiscount</span> <span class="keyword">implements</span> <span class="title class_">Discount</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> originalPrice)</span> &#123;</span><br><span class="line">        <span class="comment">// 节日打8折</span></span><br><span class="line">        <span class="keyword">return</span> originalPrice * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 订单服务（依赖抽象接口，而非具体实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">// 接收 Discount 接口，不管是哪种折扣，这里都不用改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateFinalPrice</span><span class="params">(<span class="type">double</span> originalPrice, Discount discount)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> discount.calculateDiscount(originalPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：新增功能时，直接传新的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderService</span>();</span><br><span class="line">        <span class="type">double</span> <span class="variable">originalPrice</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 会员订单</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">memberPrice</span> <span class="operator">=</span> orderService.calculateFinalPrice(originalPrice, <span class="keyword">new</span> <span class="title class_">MemberDiscount</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;会员价：&quot;</span> + memberPrice); <span class="comment">// 输出 90.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 节日订单（新增功能，旧代码没动）</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">holidayPrice</span> <span class="operator">=</span> orderService.calculateFinalPrice(originalPrice, <span class="keyword">new</span> <span class="title class_">HolidayDiscount</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;节日价：&quot;</span> + holidayPrice); <span class="comment">// 输出 80.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看到，对于折扣这个对象我们抽象出一个接口，然后对于不同类型的折扣通过接口的实现了创建具体的类。这样一来，创建订单时，我们只要区分现在要用的折扣是哪个类型的就可以了。以后要新增一个折扣类型（比如“618折扣”）只要扩展Discount这个接口就行了。</p>
<h2 id="二、里氏替换原则：子类能无缝替代父类，且不破坏程序逻辑"><a href="#二、里氏替换原则：子类能无缝替代父类，且不破坏程序逻辑" class="headerlink" title="二、里氏替换原则：子类能无缝替代父类，且不破坏程序逻辑"></a>二、里氏替换原则：子类能无缝替代父类，且不破坏程序逻辑</h2><p><strong>核心概念</strong>：简单说就是 “<strong>子类是父类的加强版，但不能颠覆父类的原有功能</strong>”。如果一个程序里用了父类对象，把它换成子类对象后，程序还能正常跑，这就符合里氏替换；反之如果换了之后程序崩了，那就是违反了这个原则。</p>
<p>最典型的反例就是 “正方形不是长方形”—— 如果把长方形的 “宽” 和 “长” 分开设置，子类正方形强制让宽 &#x3D; 长，那用子类替换父类后，修改长或宽的逻辑就会出错。</p>
<p>我们看下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 父类：鸟类（有“飞”的基础功能）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="comment">// 飞行速度</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> speed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算飞行时间（基础逻辑）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> distance / speed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置飞行速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSpeed</span><span class="params">(<span class="type">double</span> speed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 子类：麻雀（继承鸟类，不破坏父类逻辑）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="comment">// 麻雀的飞行速度有默认值，也可以通过父类方法修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sparrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = <span class="number">50</span>; <span class="comment">// 假设麻雀默认飞行速度50km/h</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 子类：老鹰（继承鸟类，扩展功能但不颠覆）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Eagle</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Eagle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = <span class="number">150</span>; <span class="comment">// 老鹰飞得更快</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增“俯冲”功能（扩展，不修改父类方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老鹰正在俯冲捕猎！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：子类替换父类，程序正常运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 父类对象</span></span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.setSpeed(<span class="number">80</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通鸟飞行时间：&quot;</span> + bird.calculateFlyTime(distance)); <span class="comment">// 100/80=1.25</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 子类麻雀替换父类</span></span><br><span class="line">        <span class="type">Bird</span> <span class="variable">sparrow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sparrow</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;麻雀飞行时间：&quot;</span> + sparrow.calculateFlyTime(distance)); <span class="comment">// 100/50=2.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 子类老鹰替换父类</span></span><br><span class="line">        <span class="type">Bird</span> <span class="variable">eagle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Eagle</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;老鹰飞行时间：&quot;</span> + eagle.calculateFlyTime(distance)); <span class="comment">// 100/150≈0.666</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 老鹰还能调用自己的扩展方法</span></span><br><span class="line">        ((Eagle) eagle).dive(); <span class="comment">// 输出“老鹰正在俯冲捕猎！”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，Sparrow和Eagle都继承自Bird这个类，是Bird的“特例”，但是本质上她们都是鸟，所以都有fly这个能力。因此就算是在另一个地方把Sparrow替换成Bird，程序也不会报错，因为它没有破坏Bird的逻辑。</p>
<h2 id="三、依赖倒置原则：依赖抽象，不依赖具体实现"><a href="#三、依赖倒置原则：依赖抽象，不依赖具体实现" class="headerlink" title="三、依赖倒置原则：依赖抽象，不依赖具体实现"></a>三、依赖倒置原则：依赖抽象，不依赖具体实现</h2><p><strong>核心概念</strong>：这条原则<strong>其实是开闭原则的 “支撑”</strong>，核心是 “高低层模块都要依赖抽象，抽象不能依赖具体”。简单说就是 —— <strong>不要让你的代码依赖某个具体的类，而是依赖接口或抽象类，这样高层模块（比如服务类）就不会被低层模块（比如工具类）的变动影响</strong>。</p>
<p>比如你开发一个 “消息通知” 功能，高层模块是 “通知服务”，低层模块是 “短信通知”“邮件通知”。如果通知服务直接依赖 “短信通知” 这个具体类，后来要加 “邮件通知”，就得改通知服务的代码；但如果依赖 “通知接口”，加新功能时只需要加个接口实现类就行。</p>
<p>我们还是来看代码示范：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象接口：消息通知（稳定的抽象层）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 低层模块1：短信通知（具体实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsNotification</span> <span class="keyword">implements</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过短信发送：&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 低层模块2：邮件通知（新增的具体实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailNotification</span> <span class="keyword">implements</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过邮件发送：&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 高层模块：通知服务（依赖抽象接口，不依赖具体实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法注入抽象接口（而非具体类）</span></span><br><span class="line">    <span class="keyword">private</span> Notification notification;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationService</span><span class="params">(Notification notification)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.notification = notification;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送消息的核心逻辑（不用改）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyUser</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        notification.send(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：高层模块无需修改，就能切换不同的通知方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 短信通知</span></span><br><span class="line">        <span class="type">NotificationService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationService</span>(<span class="keyword">new</span> <span class="title class_">SmsNotification</span>());</span><br><span class="line">        smsService.notifyUser(<span class="string">&quot;您的验证码是123456&quot;</span>); <span class="comment">// 输出“通过短信发送：您的验证码是123456”</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 邮件通知（高层模块没改，只换了实现类）</span></span><br><span class="line">        <span class="type">NotificationService</span> <span class="variable">emailService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationService</span>(<span class="keyword">new</span> <span class="title class_">EmailNotification</span>());</span><br><span class="line">        emailService.notifyUser(<span class="string">&quot;您有一封新邮件，请查收&quot;</span>); <span class="comment">// 输出“通过邮件发送：您有一封新邮件，请查收”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中：NotificationService 的notifyUser实际上是调用了Notification的send方法，但是由于它是一个抽象方法，具体的实现都在不同的通知类中，因此当服务方法调用时，只要指派不同的通知类即可。<br>这里的核心是NotificationService 依赖的只是 Notification 这个抽象接口，这样方便后续的扩展。假设未来如果有了新的通知类型，比如微信通知，那么创建一个WeChatNotification并实现Notification即可。</p>
<h2 id="四、组合-聚合原则：优先用组合-聚合，少用继承"><a href="#四、组合-聚合原则：优先用组合-聚合，少用继承" class="headerlink" title="四、组合 &#x2F; 聚合原则：优先用组合 &#x2F; 聚合，少用继承"></a>四、组合 &#x2F; 聚合原则：优先用组合 &#x2F; 聚合，少用继承</h2><p><strong>核心概念</strong>：继承的问题在于 “强耦合”—— 子类会依赖父类的实现，如果父类改了，子类可能跟着崩；而组合 &#x2F; 聚合是 “弱耦合”—— <strong>一个类通过 “包含另一个类的对象” 来使用其功能，双方可以独立变化</strong>。所以设计时要优先选组合 &#x2F; 聚合，实在适合继承（比如子类是父类的 “is-a” 关系）再用继承。</p>
<p>比如 “汽车” 和 “发动机” 的关系：汽车需要发动机才能跑，但汽车不是 “继承” 发动机（因为汽车不是发动机的一种），而是 “组合” 发动机（汽车里包含一个发动机对象）；而 “轿车” 和 “汽车” 是 “is-a” 关系，适合用继承。</p>
<p>我们来看代码的示范：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 发动机类（被组合的类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="comment">// 发动机启动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发动机启动，开始提供动力&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发动机停止</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发动机停止，动力中断&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 汽车类（组合发动机，而非继承）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 汽车包含一个发动机对象（组合关系：汽车销毁时，发动机也跟着销毁）</span></span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法初始化发动机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = <span class="keyword">new</span> <span class="title class_">Engine</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 汽车启动：调用发动机的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startCar</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车成功启动，可以行驶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 汽车停止：调用发动机的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopCar</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车成功停止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 轿车类（继承汽车，因为轿车是汽车的一种）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sedan</span> <span class="keyword">extends</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 轿车的特有功能：自动泊车</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoParking</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;轿车正在自动泊车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：组合和继承的正确使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sedan</span> <span class="variable">sedan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sedan</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用继承自Car的方法（依赖组合的Engine）</span></span><br><span class="line">        sedan.startCar(); </span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 发动机启动，开始提供动力</span></span><br><span class="line">        <span class="comment">// 汽车成功启动，可以行驶</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Sedan的特有方法</span></span><br><span class="line">        sedan.autoParking(); <span class="comment">// 输出“轿车正在自动泊车”</span></span><br><span class="line">        </span><br><span class="line">        sedan.stopCar();</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 发动机停止，动力中断</span></span><br><span class="line">        <span class="comment">// 汽车成功停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、接口隔离原则：接口要小而专，不要大而全"><a href="#五、接口隔离原则：接口要小而专，不要大而全" class="headerlink" title="五、接口隔离原则：接口要小而专，不要大而全"></a>五、接口隔离原则：接口要小而专，不要大而全</h2><p><strong>核心概念</strong>：这条原则是说 —— <strong>不要设计一个 “万能接口”，把所有功能都塞进去，而是要把接口拆成多个 “专用接口”，让类只实现自己需要的接口。</strong> 这样能避免 “类实现了接口，但被迫重写不需要的方法”（比如空实现），也能减少接口变动的影响。 </p>
<p>比如 “用户系统” 里，普通用户只需要 “登录、注册” 功能，管理员需要 “用户管理、权限管理” 功能。如果设计一个 “UserInterface” 包含所有 4 个方法，普通用户类就得空实现 “用户管理、权限管理”，这就很不合理；拆成两个接口后，各自实现需要的方法即可。</p>
<p>还是来看示范代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 拆分成专用接口：普通用户接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NormalUserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>; <span class="comment">// 登录</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username, String password)</span>; <span class="comment">// 注册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 拆分成专用接口：管理员接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">manageUser</span><span class="params">(String userId)</span>; <span class="comment">// 管理用户</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">managePermission</span><span class="params">(String roleId)</span>; <span class="comment">// 管理权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 普通用户类：只实现自己需要的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalUser</span> <span class="keyword">implements</span> <span class="title class_">NormalUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(username + <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(username + <span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 管理员类：实现管理员接口，也可以实现普通用户接口（如果需要）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> <span class="keyword">implements</span> <span class="title class_">NormalUserService</span>, AdminService &#123;</span><br><span class="line">    <span class="comment">// 实现普通用户接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;管理员&quot;</span> + username + <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 管理员可能不需要注册，或有特殊逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;管理员账号需通过审批注册&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现管理员接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manageUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功管理用户：&quot;</span> + userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">managePermission</span><span class="params">(String roleId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功管理角色权限：&quot;</span> + roleId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：每个类只处理自己需要的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NormalUser</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NormalUser</span>();</span><br><span class="line">        user.login(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123456&quot;</span>); <span class="comment">// 输出“zhangsan登录成功”</span></span><br><span class="line">        user.register(<span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;654321&quot;</span>); <span class="comment">// 输出“lisi注册成功”</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br><span class="line">        admin.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;admin123&quot;</span>); <span class="comment">// 输出“管理员admin登录成功”</span></span><br><span class="line">        admin.manageUser(<span class="string">&quot;1001&quot;</span>); <span class="comment">// 输出“成功管理用户：1001”</span></span><br><span class="line">        admin.managePermission(<span class="string">&quot;admin_role&quot;</span>); <span class="comment">// 输出“成功管理角色权限：admin_role”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、最少知识原则：一个类只和-“直接朋友”-通信，别和-“陌生人”-说话"><a href="#六、最少知识原则：一个类只和-“直接朋友”-通信，别和-“陌生人”-说话" class="headerlink" title="六、最少知识原则：一个类只和 “直接朋友” 通信，别和 “陌生人” 说话"></a>六、最少知识原则：一个类只和 “直接朋友” 通信，别和 “陌生人” 说话</h2><p><strong>核心概念</strong>：也叫 “迪米特法则”，核心是 “降低类之间的耦合”—— <strong>一个类应该只和它的 “直接朋友”（比如成员变量、方法参数、返回值里的类）交互，不要主动去调用 “朋友的朋友” 的方法</strong>。这样能减少类之间的依赖，让系统更稳定。</p>
<p>比如 “老板要统计部门的员工数量”：老板的直接朋友是 “部门”，部门的直接朋友是 “员工”。如果老板直接去遍历部门里的员工列表，就是和 “员工”（陌生人）通信了；正确的做法是老板让部门自己统计人数，然后把结果返回给老板。</p>
<p>看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 员工类（部门的直接朋友，老板的陌生人）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">// 员工的基本信息（不需要暴露给老板）</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 部门类（老板的直接朋友，员工的直接朋友）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="comment">// 部门里有员工列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employees;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">()</span> &#123;</span><br><span class="line">        employees = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 模拟添加3个员工</span></span><br><span class="line">        employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>));</span><br><span class="line">        employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">28</span>));</span><br><span class="line">        employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 部门自己提供“统计人数”的方法（对外隐藏员工列表）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEmployeeCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> employees.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 老板类（只和部门通信，不和员工通信）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boss</span> &#123;</span><br><span class="line">    <span class="comment">// 老板统计部门人数：只调用部门的方法（直接朋友）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDepartmentEmployees</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> department.getEmployeeCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前部门员工数量：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：符合最少知识原则，耦合度低</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Boss</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boss</span>();</span><br><span class="line">        <span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 老板只和部门交互，不知道员工的存在</span></span><br><span class="line">        boss.countDepartmentEmployees(department); <span class="comment">// 输出“当前部门员工数量：3”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后：六大原则不是-“教条”，而是-“工具”"><a href="#写在最后：六大原则不是-“教条”，而是-“工具”" class="headerlink" title="写在最后：六大原则不是 “教条”，而是 “工具”"></a>写在最后：六大原则不是 “教条”，而是 “工具”</h2><p>很多人学完这些原则后会陷入 “过度设计” 的误区 —— 为了凑齐原则，写了一堆复杂的接口和类，反而让代码更难维护。</p>
<p>其实这六大原则的核心目标是一致的：<strong>降低耦合、提高内聚、让代码更易扩展和维护</strong>。实际开发中，不需要强行遵守每一条，而是要根据场景灵活取舍（比如简单的工具类，用继承可能比组合更简单）。</p>
<p>记住：<strong>好的设计不是 “符合多少原则”，而是 “能解决当前问题，且能应对未来的合理变化”。</strong> </p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/09/03/08%20%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-GoF-%E7%9A%84-23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%8E%E6%A6%82%E5%BF%B5%E5%88%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">一文搞懂 GoF 的 23 种设计模式：从概念到代码实现</a><a class="next" href="/2025/09/02/03%20Mandel%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E9%BB%84%E9%87%91%E4%B8%89%E5%8E%9F%E5%88%99/">从“不会用”到“离不开”：Theo Mandel人机交互设计“黄金三原则”</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>重要的不是发生了什么，而是你如何应对它。</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8B%BE%E7%A9%97%E9%9B%86/">拾穗集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%A1%E7%90%86/">管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1/">设计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/uv/" style="font-size: 15px;">uv</a> <a href="/tags/ai/" style="font-size: 15px;">ai</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/" style="font-size: 15px;">工作流</a> <a href="/tags/%E6%A8%A1%E5%9D%97%E8%80%A6%E5%90%88/" style="font-size: 15px;">模块耦合</a> <a href="/tags/%E8%AE%A4%E7%9F%A5/" style="font-size: 15px;">认知</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E5%B8%88/" style="font-size: 15px;">系统分析师</a> <a href="/tags/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/" style="font-size: 15px;">需求分析</a> <a href="/tags/%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96/" style="font-size: 15px;">需求获取</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E8%8C%83%E5%BC%8F/" style="font-size: 15px;">范式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 15px;">项目管理</a> <a href="/tags/%E6%80%BB%E6%97%B6%E5%B7%AE/" style="font-size: 15px;">总时差</a> <a href="/tags/%E8%87%AA%E7%94%B1%E6%97%B6%E5%B7%AE/" style="font-size: 15px;">自由时差</a> <a href="/tags/%E7%9F%A5%E4%B9%8E/" style="font-size: 15px;">知乎</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 15px;">转载</a> <a href="/tags/%E5%86%99%E4%BD%9C/" style="font-size: 15px;">写作</a> <a href="/tags/%E4%BA%A7%E5%93%81/" style="font-size: 15px;">产品</a> <a href="/tags/%E5%A5%B3%E5%84%BF/" style="font-size: 15px;">女儿</a> <a href="/tags/%E6%88%90%E5%8A%9F/" style="font-size: 15px;">成功</a> <a href="/tags/%E6%A6%82%E7%8E%87/" style="font-size: 15px;">概率</a> <a href="/tags/%E9%80%89%E6%8B%A9/" style="font-size: 15px;">选择</a> <a href="/tags/%E9%BB%84%E4%BB%81%E5%8B%8B/" style="font-size: 15px;">黄仁勋</a> <a href="/tags/AI/" style="font-size: 15px;">AI</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">编程</a> <a href="/tags/pip/" style="font-size: 15px;">pip</a> <a href="/tags/CogTTS/" style="font-size: 15px;">CogTTS</a> <a href="/tags/Firecrawl/" style="font-size: 15px;">Firecrawl</a> <a href="/tags/Office/" style="font-size: 15px;">Office</a> <a href="/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" style="font-size: 15px;">插件开发</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 15px;">数学</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 15px;">区块链</a> <a href="/tags/fisco-bcos/" style="font-size: 15px;">fisco-bcos</a> <a href="/tags/fisco-bcos/" style="font-size: 15px;">fisco bcos</a> <a href="/tags/%E8%8A%AF%E7%89%87/" style="font-size: 15px;">芯片</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E9%9D%92%E6%98%A5%E6%9C%9F/" style="font-size: 15px;">青春期</a> <a href="/tags/%E6%95%99%E8%82%B2/" style="font-size: 15px;">教育</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/10/23/66-%E3%80%8A%E8%A7%A3%E7%A0%81%E9%9D%92%E6%98%A5%E6%9C%9F%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">《解码青春期》第二章阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/22/65-%E3%80%8A%E8%A7%A3%E7%A0%81%E9%9D%92%E6%98%A5%E6%9C%9F%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《解码青春期》第一章-读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/20/64-%E5%AE%89%E8%A3%85Gradle-6-3/">64 安装Gradle 6.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/20/62-CentOS-%E4%B8%8A%E6%90%AD%E5%BB%BAWeBase/">62 CentOS 上搭建WeBase</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/16/63%20%E5%85%B3%E4%BA%8E%E6%96%B0%E9%97%BB%EF%BC%9A%E3%80%8A%E5%8C%97%E5%A4%A7%E6%88%90%E5%8A%9F%E7%A0%94%E5%88%B6%E5%87%BA%E6%96%B0%E5%9E%8B%E8%8A%AF%E7%89%87%EF%BC%8C%E7%AE%97%E5%8A%9B%E5%8F%AF%E8%B6%85%E9%A1%B6%E7%BA%A7GPU1000%E5%80%8D%E3%80%8B%E7%9A%84%E8%A7%A3%E8%AF%BB/">关于新闻：《北大成功研制出新型芯片，算力可超顶级GPU1000倍》的解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/16/61-FISCO-BCOS-%E6%8E%A7%E5%88%B6%E5%8F%B0/">FISCO BCOS 控制台的操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/16/60-%E6%90%AD%E5%BB%BAFISCO-BCOS%E5%A4%9A%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C/">搭建FISCO BCOS多主机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/15/59-%E4%BF%AE%E6%94%B9Fisco-Bcos%E7%9A%84%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE/">修改Fisco Bcos的节点配置，实现外网访问</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/10/58-%E6%90%AD%E5%BB%BAFisco-Bcos%E7%9A%84%E7%AE%A1%E7%90%86%E7%AB%AFWeBase-Front/">搭建Fisco-Bcos的管理端WeBase-Front</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/10/10/57-CentOS-%E4%B8%8B%E5%AE%89%E8%A3%85Fisco-Bcos/">CentOS 下安装Fisco Bcos</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://zhuanlan.zhihu.com/column/c_1933254499415359834" title="知乎专栏" target="_blank">知乎专栏</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">解.方.程.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">京ICP备2024100693号-1</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>